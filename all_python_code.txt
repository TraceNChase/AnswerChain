################################################################################
# START OF FILE: "CipherForge.py"
################################################################################

"""
FILENAME:
"CipherForge.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

import os
import base64
from typing import Dict, Tuple, Optional

import argon2.low_level
import argon2.exceptions

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

# Logging
from modules.debug_utils import log_debug, log_crypto_event


def derive_key_argon2id(password: str,
                        salt: bytes,
                        key_length: int = 32,
                        time_cost: int = 3,
                        memory_cost: int = 65536,
                        parallelism: int = 4,
                        ephemeral: bool = False) -> bytes:
    ephemeral_info = {
        "salt_b64": base64.b64encode(salt).decode(),
        "ephemeral_password": password if ephemeral else "<not ephemeral>"
    }
    log_debug(
        f"Starting Argon2id KDF: pass='{password}', salt(b64)='{ephemeral_info['salt_b64']}'",
        level="INFO",
        component="CRYPTO"
    )
    derived_bytes = argon2.low_level.hash_secret(
        secret=password.encode("utf-8"),
        salt=salt,
        time_cost=time_cost,
        memory_cost=memory_cost,
        parallelism=parallelism,
        hash_len=key_length,
        type=argon2.low_level.Type.ID
    )
    if len(derived_bytes) > key_length:
        derived_bytes = derived_bytes[:key_length]

    log_crypto_event(
        operation="KDF Derive",
        algorithm="Argon2id",
        ephemeral=ephemeral,
        ephemeral_key=derived_bytes,
        argon_params={
            "time_cost": time_cost,
            "memory_cost": memory_cost,
            "parallelism": parallelism,
            "key_length": key_length
        },
        key_derived_bytes=derived_bytes,
        details={
            "message": "Argon2id complete. Derived key is in logs.",
            "ephemeral_info": ephemeral_info
        }
    )
    return derived_bytes


def encrypt_aes256gcm(plaintext: bytes,
                      key: bytes,
                      ephemeral_pass: Optional[str] = None,
                      ephemeral_salt: Optional[bytes] = None) -> Dict[str, str]:
    if not isinstance(plaintext, bytes):
        plaintext = str(plaintext).encode("utf-8")

    nonce = os.urandom(12)
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce))
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    tag = encryptor.tag

    ephemeral_details = {
        "Nonce(base64)": base64.b64encode(nonce).decode(),
        "Ciphertext(base64)": base64.b64encode(ciphertext).decode(),
        "Tag(base64)": base64.b64encode(tag).decode()
    }
    if ephemeral_pass is not None:
        ephemeral_details["ephemeral_password"] = ephemeral_pass
    if ephemeral_salt is not None:
        ephemeral_details["ephemeral_salt_b64"] = base64.b64encode(ephemeral_salt).decode()

    log_crypto_event(
        operation="Encrypt",
        algorithm="AES-256",
        mode="GCM",
        ephemeral_key=key,
        details=ephemeral_details,
        ephemeral=True
    )
    return {
        "alg": "AES-256-GCM",
        "ciphertext": ephemeral_details["Ciphertext(base64)"],
        "nonce": ephemeral_details["Nonce(base64)"],
        "tag": ephemeral_details["Tag(base64)"]
    }


def decrypt_aes256gcm(encrypted_data: Dict[str, str], key: bytes) -> bytes:
    import base64
    ciphertext = base64.b64decode(encrypted_data['ciphertext'])
    nonce = base64.b64decode(encrypted_data['nonce'])
    tag = base64.b64decode(encrypted_data['tag'])

    log_crypto_event(
        operation="Decrypt",
        algorithm="AES-256",
        mode="GCM",
        ephemeral_key=key,
        details={
            "Nonce(base64)": encrypted_data['nonce'],
            "Ciphertext(base64)": encrypted_data['ciphertext'],
            "Tag(base64)": encrypted_data['tag']
        },
        ephemeral=True
    )

    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce, tag))
    decryptor = cipher.decryptor()
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext


def encrypt_chacha20poly1305(plaintext: bytes,
                             key: bytes,
                             ephemeral_pass: Optional[str] = None,
                             ephemeral_salt: Optional[bytes] = None) -> Dict[str, str]:
    import base64
    if not isinstance(plaintext, bytes):
        plaintext = str(plaintext).encode("utf-8")

    nonce = os.urandom(12)
    cipher = ChaCha20Poly1305(key)
    ciphertext = cipher.encrypt(nonce, plaintext, b"")

    ephemeral_details = {
        "Nonce(base64)": base64.b64encode(nonce).decode(),
        "Ciphertext(base64)": base64.b64encode(ciphertext).decode()
    }
    if ephemeral_pass is not None:
        ephemeral_details["ephemeral_password"] = ephemeral_pass
    if ephemeral_salt is not None:
        ephemeral_details["ephemeral_salt_b64"] = base64.b64encode(ephemeral_salt).decode()

    log_crypto_event(
        operation="Encrypt",
        algorithm="ChaCha20-Poly1305",
        mode="Poly1305",
        ephemeral_key=key,
        details=ephemeral_details,
        ephemeral=True
    )
    return {
        "alg": "ChaCha20-Poly1305",
        "ciphertext": ephemeral_details["Ciphertext(base64)"],
        "nonce": ephemeral_details["Nonce(base64)"]
    }


def decrypt_chacha20poly1305(enc_data: Dict[str, str], key: bytes) -> bytes:
    import base64
    nonce = base64.b64decode(enc_data['nonce'])
    ciphertext = base64.b64decode(enc_data['ciphertext'])

    log_crypto_event(
        operation="Decrypt",
        algorithm="ChaCha20-Poly1305",
        mode="Poly1305",
        ephemeral_key=key,
        details={
            "Nonce(base64)": enc_data['nonce'],
            "Ciphertext(base64)": enc_data['ciphertext']
        },
        ephemeral=True
    )

    cipher = ChaCha20Poly1305(key)
    plaintext = cipher.decrypt(nonce, ciphertext, b"")
    return plaintext


def derive_or_recover_key(password: str,
                          salt: Optional[bytes] = None,
                          ephemeral: bool = False,
                          time_cost: int = 3,
                          memory_cost: int = 65536,
                          parallelism: int = 4) -> Tuple[bytes, bytes]:
    if salt is None:
        salt = os.urandom(16)

    if ephemeral:
        log_debug(f"Using ephemeral password='{password}' (raw).", level="INFO", component="CRYPTO")
    else:
        log_debug(f"Using user-provided password='{password}' (raw).", level="INFO", component="CRYPTO")

    key = derive_key_argon2id(
        password, 
        salt, 
        ephemeral=ephemeral,
        time_cost=time_cost,
        memory_cost=memory_cost,
        parallelism=parallelism
    )
    return key, salt

################################################################################
# END OF FILE: "CipherForge.py"
################################################################################




################################################################################
# START OF FILE: "main.py"
################################################################################

"""
FILENAME:
"main.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Main flow with mandatory Argon2id usage for all encryption,
ensuring ephemeral keys/ciphertext are fully logged so
the secret can be rebuilt from logs alone.

All references to any 'decoy' secret have been removed. Only a single real secret
is stored across shares for correct (real) answers; incorrect answers contain dummy shares.
"""

import os
import sys
import json
import base64
import curses
import asyncio
import secrets
import threading
from random import choice
from pathlib import Path

# from modules
from modules.debug_utils import ensure_debug_dir, log_debug, log_error, append_recovery_guide
from modules.security_utils import validate_question, hash_share, verify_share_hash
from modules.input_utils import get_valid_int, get_nonempty_secret
from modules.ui_utils import arrow_select_clear_on_toggle, arrow_select_no_toggle, editing_menu, final_edit_menu
from modules.split_utils import split_secret_and_dummy
from modules.SSS import sss_combine

# from CipherForge
from CipherForge import (
    derive_or_recover_key,
    encrypt_aes256gcm,
    decrypt_aes256gcm,
    encrypt_chacha20poly1305,
    decrypt_chacha20poly1305
)

SRC_DIR = Path(__file__).parent.resolve()
QUESTIONS_FILE_NAME = "example_questions25.json"
QUESTIONS_PATH = SRC_DIR / QUESTIONS_FILE_NAME

chosen_lock = threading.Lock()
combine_lock = threading.Lock()
critical_question_counter = 0

def check_required_files():
    needed_in_src = [
        "CipherForge.py",
        "example_questions25.json"
    ]
    missing = []
    for f in needed_in_src:
        if not (SRC_DIR / f).exists():
            missing.append(f)

    modules_path = SRC_DIR / "modules"
    needed_in_modules = [
        "debug_utils.py",
        "input_utils.py",
        "log_processor.py",
        "security_utils.py",
        "split_utils.py",
        "SSS.py",
        "ui_utils.py"
    ]
    for f in needed_in_modules:
        if not (modules_path / f).exists():
            missing.append(f)

    if missing:
        print("ERROR - Missing:", missing)
        sys.exit(1)

def convert_to_json_serializable(obj):
    """
    Recursively convert any bytearray/bytes objects
    into base64-encoded strings so we can safely JSON-serialize them.
    """
    if isinstance(obj, dict):
        return {k: convert_to_json_serializable(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_to_json_serializable(x) for x in obj]
    elif isinstance(obj, (bytes, bytearray)):
        return base64.b64encode(obj).decode()
    else:
        return obj

def prompt_argon2_parameters():
    """
    Prompt user for Argon2id parameter choice:
      - (n): use defaults
      - (e): enter custom values
    Returns (time_cost, memory_cost, parallelism).
    """
    print("\n--- Argon2id Parameter Setup ---")
    choice_ = input("Use (n) for normal defaults or (e) for custom edit? [n/e] ").strip().lower()
    if choice_ != 'e':
        # Default
        print("Using DEFAULT Argon2id parameters: time_cost=3, memory_cost=65536, parallelism=4")
        return (3, 65536, 4)
    else:
        # Custom
        print("Enter custom Argon2id parameters:")
        tc = get_valid_int("time_cost (1..10)? ", 1, 10)
        mc = get_valid_int("memory_cost (8192..1048576)? ", 8192, 1048576)
        pl = get_valid_int("parallelism (1..32)? ", 1, 32)
        print(f"Using CUSTOM Argon2id parameters: time_cost={tc}, memory_cost={mc}, parallelism={pl}")
        return (tc, mc, pl)

def main():
    print("[INFO] Launching main.py...")  # Ensures user sees output immediately

    # 1) Initialize debug logs
    ensure_debug_dir()
    check_required_files()
    log_debug("Starting program...", level="INFO")

    # 2) Load question data
    if not QUESTIONS_PATH.exists():
        print(f"Error: question file not found: {QUESTIONS_PATH}")
        return
    try:
        with open(QUESTIONS_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
        valid_data = [q for q in data if validate_question(q)]
    except Exception as e:
        log_error("Error loading question file", e)
        return

    if not valid_data:
        print("No valid questions found. Aborting.")
        return

    amt = get_valid_int(f"How many questions? (1..{len(valid_data)}): ", 1, len(valid_data))
    with chosen_lock:
        chosen = valid_data[:amt]

    # 3) selection
    with chosen_lock:
        for i, qdict in enumerate(chosen, 1):
            fixed = qdict.get("force_type")
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, i, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=fixed
                )
            )
            qdict["user_answers"] = picks
            if fixed:
                qdict["is_critical"] = (fixed.upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)

    # 4) editing
    while True:
        with chosen_lock:
            done = editing_menu(chosen)
        if done:
            break

    # 5) Tally
    correct_map = []
    incorrect_map = []
    with chosen_lock:
        for q in chosen:
            for alt in q["alternatives"]:
                if alt in q["user_answers"]:
                    correct_map.append((q, alt))
                else:
                    incorrect_map.append((q, alt))
    c_count = len(correct_map)
    i_count = len(incorrect_map)
    print(f"\nCorrect picks={c_count}, Incorrect={i_count}.\n")

    # 6) The real secret
    real_secret = get_nonempty_secret("Enter REAL secret: ")
    real_b64 = base64.b64encode(real_secret.encode()).decode()

    if c_count < 10:
        print("Fewer than 10 correct => cannot proceed.")
        return

    r_thr = get_valid_int(f"Real threshold (10..{c_count}): ", 10, c_count)
    print(f"[INFO] Must pick >= {r_thr} correct for REAL secret.\n")

    # 7) optional pad
    print("Custom PAD size? Press ENTER to use default=128.")
    try_pad = input("PAD >= length of base64 secret? ").strip()
    if try_pad:
        try:
            user_pad = int(try_pad)
            min_len = len(real_b64)
            if user_pad < min_len:
                print("Too small, using 128.")
                user_pad = 128
        except:
            print("Invalid, using 128.")
            user_pad = 128
    else:
        user_pad = 128

    # 8) Argon2id parameter choice
    argon_time_cost, argon_mem_cost, argon_par = prompt_argon2_parameters()

    # 9) SSS split (real shares + dummy shares)
    try:
        real_shares, dummy_shares = asyncio.run(
            split_secret_and_dummy(
                real_b64.encode(),
                c_count,
                i_count,
                r_thr,
                pad=user_pad
            )
        )
    except Exception as e:
        log_error("Error splitting secret", e)
        return

    # 10) ephemeral encryption for CRITICAL
    global critical_question_counter
    c_idx = 0
    for (qq, alt) in correct_map:
        share_data = real_shares[c_idx]
        c_idx += 1
        is_crit = qq["is_critical"]
        stored = bytearray(share_data)
        share_hash_val = hash_share(stored)
        for i in range(len(share_data)):
            share_data[i] = 0  # wipe ephemeral in memory

        qq.setdefault("answer_shares", {})
        if is_crit:
            critical_question_counter += 1
            ephemeral_pass = base64.b64encode(os.urandom(12)).decode()
            ephemeral_salt = os.urandom(16)
            ephemeral_key, ephemeral_salt_used = derive_or_recover_key(
                ephemeral_pass,
                ephemeral_salt,
                ephemeral=True,
                time_cost=argon_time_cost,
                memory_cost=argon_mem_cost,
                parallelism=argon_par
            )

            alg_options = ["chacha20poly1305", "aes256gcm"]
            alg = choice(alg_options)

            if alg == "chacha20poly1305":
                enc_dict = encrypt_chacha20poly1305(
                    bytes(stored),
                    ephemeral_key,
                    ephemeral_pass=ephemeral_pass,
                    ephemeral_salt=ephemeral_salt_used
                )
            else:
                enc_dict = encrypt_aes256gcm(
                    bytes(stored),
                    ephemeral_key,
                    ephemeral_pass=ephemeral_pass,
                    ephemeral_salt=ephemeral_salt_used
                )

            enc_dict["ephemeral_password"] = ephemeral_pass
            enc_dict["ephemeral_salt_b64"] = base64.b64encode(ephemeral_salt_used).decode()
            enc_dict["algorithm"] = alg

            qq["answer_shares"][alt] = {
                "critical": True,
                "alg": alg,
                "enc": enc_dict,
                "hash": share_hash_val,
                "is_real": True
            }
        else:
            qq["answer_shares"][alt] = {
                "critical": False,
                "plain": stored,
                "hash": share_hash_val,
                "is_real": True
            }

    i_idx = 0
    for (qq, alt) in incorrect_map:
        share_data = dummy_shares[i_idx]
        i_idx += 1
        is_crit = qq["is_critical"]
        stored = bytearray(share_data)
        share_hash_val = hash_share(stored)
        for j in range(len(share_data)):
            share_data[j] = 0  # wipe ephemeral in memory

        qq.setdefault("answer_shares", {})
        if is_crit:
            critical_question_counter += 1
            ephemeral_pass = base64.b64encode(os.urandom(12)).decode()
            ephemeral_salt = os.urandom(16)
            ephemeral_key, ephemeral_salt_used = derive_or_recover_key(
                ephemeral_pass,
                ephemeral_salt,
                ephemeral=True,
                time_cost=argon_time_cost,
                memory_cost=argon_mem_cost,
                parallelism=argon_par
            )

            alg_options = ["chacha20poly1305", "aes256gcm"]
            alg = choice(alg_options)

            if alg == "chacha20poly1305":
                enc_dict = encrypt_chacha20poly1305(
                    bytes(stored),
                    ephemeral_key,
                    ephemeral_pass=ephemeral_pass,
                    ephemeral_salt=ephemeral_salt_used
                )
            else:
                enc_dict = encrypt_aes256gcm(
                    bytes(stored),
                    ephemeral_key,
                    ephemeral_pass=ephemeral_pass,
                    ephemeral_salt=ephemeral_salt_used
                )

            enc_dict["ephemeral_password"] = ephemeral_pass
            enc_dict["ephemeral_salt_b64"] = base64.b64encode(ephemeral_salt_used).decode()
            enc_dict["algorithm"] = alg

            qq["answer_shares"][alt] = {
                "critical": True,
                "alg": alg,
                "enc": enc_dict,
                "hash": share_hash_val,
                "is_real": False
            }
        else:
            qq["answer_shares"][alt] = {
                "critical": False,
                "plain": stored,
                "hash": share_hash_val,
                "is_real": False
            }

    # zero out original shares
    for s in real_shares:
        for i in range(len(s)):
            s[i] = 0
    for s in dummy_shares:
        for i in range(len(s)):
            s[i] = 0

    print("\n--- Final Answering Phase ---\n")
    with chosen_lock:
        for i, q in enumerate(chosen, 1):
            picks2 = curses.wrapper(
                lambda st: arrow_select_no_toggle(
                    st, i, q["text"], q["alternatives"],
                    pre_selected=q.get("user_answers")
                )
            )
            q["user_answers"] = picks2

    while True:
        with chosen_lock:
            result = final_edit_menu(chosen)
        if result == 'G':
            log_debug("User finalize => combine secrets now.", level="INFO")
            break
        elif result == 'N':
            print("Aborted. Exiting.")
            return

    # 11) Combine ephemeral shares to reconstruct real secret
    final_real_shares = []

    with chosen_lock:
        for q_index, q in enumerate(chosen, 1):
            for alt in q["user_answers"]:
                info = q["answer_shares"][alt]
                if info["critical"]:
                    enc_data = info["enc"]
                    ephemeral_pass = enc_data["ephemeral_password"]
                    ephemeral_salt_b64 = enc_data["ephemeral_salt_b64"]
                    ephemeral_salt = base64.b64decode(ephemeral_salt_b64)

                    ephemeral_key, _ = derive_or_recover_key(
                        ephemeral_pass,
                        ephemeral_salt,
                        ephemeral=True,
                        time_cost=argon_time_cost,
                        memory_cost=argon_mem_cost,
                        parallelism=argon_par
                    )
                    alg = enc_data["algorithm"]
                    if alg == "chacha20poly1305":
                        pt = decrypt_chacha20poly1305(enc_data, ephemeral_key)
                    else:
                        pt = decrypt_aes256gcm(enc_data, ephemeral_key)

                    if not verify_share_hash(pt, info["hash"]):
                        log_debug(f"CRITICAL share mismatch Q{q_index}", level="ERROR")
                    if info["is_real"]:
                        final_real_shares.append(bytearray(pt))
                else:
                    if not verify_share_hash(info["plain"], info["hash"]):
                        log_debug(f"Non-critical share mismatch Q{q_index}", level="ERROR")
                    if info["is_real"]:
                        final_real_shares.append(info["plain"])

    reconstructed_real = None
    with combine_lock:
        try:
            if len(final_real_shares) >= r_thr:
                combined = asyncio.run(sss_combine(final_real_shares))
                try:
                    dec_real = base64.b64decode(combined).decode()
                    reconstructed_real = dec_real
                except Exception as e:
                    reconstructed_real = f"<Decode error: {e}>"
        except Exception as e:
            log_error("Combine fail", e)

    print("\n--- FINAL RECONSTRUCTION RESULTS ---\n")
    if reconstructed_real and not reconstructed_real.startswith("<"):
        print(f"REAL SECRET recovered: {reconstructed_real}\n")
    else:
        print("Secret not recoverable. Threshold not met or data mismatch.\n")

    print("""
--- Steps to manually reconstruct (if not done above) ---
1. Collect final correct answers from logs.
2. For CRITICAL shares, ephemeral Argon2id pass & salt in logs => re-derive => decrypt.
3. For non-critical, share data is in plaintext (already in logs).
4. Provide all correct shares to SSS.combine() => then base64-decode final secret.
""")

    append_recovery_guide()
    log_debug("Done with main program.", level="INFO")


if __name__ == "__main__":
    main()

################################################################################
# END OF FILE: "main.py"
################################################################################




################################################################################
# START OF FILE: "debug_utils.py"
################################################################################

"""
FILENAME:
"debug_utils.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Logs ephemeral keys, ephemeral pass, ephemeral salt, etc. in plain,
so secrets can be fully reconstructed from logs alone.

WARNING: Extremely insecure for real usage.
"""

import os
import json
import uuid
import inspect
import threading
import shutil
import time
from datetime import datetime, timedelta
from pathlib import Path

BASE_DIR = Path(__file__).parent.parent.resolve()
DEBUG_COLLECTION_DIR = BASE_DIR / "logs" / "debug_logs"
DEBUG_COLLECTION_DIR.mkdir(parents=True, exist_ok=True)

RUN_ID = str(uuid.uuid4())

VERBOSITY_LEVELS = {
    "DEBUG": 10,
    "INFO": 20,
    "WARNING": 30,
    "ERROR": 40,
    "CRITICAL": 50
}
LOG_VERBOSITY = os.environ.get("LOG_VERBOSITY", "DEBUG").upper()
CURRENT_VERBOSITY = VERBOSITY_LEVELS.get(LOG_VERBOSITY, 10)

DEBUG_FILE_JSON = None
DEBUG_FILE_TXT = None
log_lock = threading.Lock()

def get_next_log_counter() -> int:
    counter = 1
    for file in DEBUG_COLLECTION_DIR.iterdir():
        if file.is_file() and file.name.startswith("debug_info") and file.name.endswith(".json"):
            try:
                cor = file.name.replace("debug_info", "").replace(".json", "")
                num_part = cor.split("_", maxsplit=1)[0]
                n = int(num_part)
                if n >= counter:
                    counter = n + 1
            except:
                pass
    return counter

def get_timestamp() -> str:
    return datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

def archive_old_logs(days=7):
    arch = DEBUG_COLLECTION_DIR / "archive"
    arch.mkdir(exist_ok=True)
    cutoff = datetime.now() - timedelta(days=days)
    for f in DEBUG_COLLECTION_DIR.iterdir():
        if f.is_file() and f.name.startswith("debug_info") and f.suffix in [".json", ".txt"]:
            mtime = datetime.fromtimestamp(f.stat().st_mtime)
            if mtime < cutoff:
                shutil.move(str(f), str(arch / f.name))

def ensure_debug_dir():
    global DEBUG_FILE_JSON, DEBUG_FILE_TXT
    archive_old_logs(days=7)
    c = get_next_log_counter()
    ts = get_timestamp()
    DEBUG_FILE_JSON = DEBUG_COLLECTION_DIR / f"debug_info{c}_{ts}.json"
    DEBUG_FILE_TXT = DEBUG_COLLECTION_DIR / f"debug_info{c}_{ts}.txt"

    start_entry = {
        "timestamp": datetime.now().isoformat(),
        "run_id": RUN_ID,
        "component": "SYSTEM",
        "level": "INFO",
        "message": "Start new run",
        "details": {"event": "Run Initialization"}
    }
    with log_lock:
        with open(DEBUG_FILE_JSON, "a", encoding="utf-8") as jf, open(DEBUG_FILE_TXT, "a", encoding="utf-8") as tf:
            jf.write(json.dumps(start_entry, indent=2) + "\n")
            tf.write(f"[{start_entry['timestamp']}] [INFO] [SYSTEM] Start new run (run_id={RUN_ID})\n")

    print(f"[DEBUG] Logging to JSON: {DEBUG_FILE_JSON}")
    print(f"[DEBUG] Logging to TXT : {DEBUG_FILE_TXT}")

def _write_log_json(entry: dict):
    with open(DEBUG_FILE_JSON, "a", encoding="utf-8") as jf:
        jf.write(json.dumps(entry, indent=2) + "\n")

def _write_log_txt(entry: dict):
    timestamp = entry.get("timestamp", "N/A")
    lvl = entry.get("level", "N/A")
    comp = entry.get("component", "N/A")
    caller = entry.get("caller", {})
    file_ = caller.get("file", "?")
    func_ = caller.get("function", "?")
    line_ = caller.get("line", "?")
    msg = entry.get("message", "")
    details = entry.get("details", {})
    ev = ""
    if "event" in details:
        ev = f" (event={details['event']})"
    line_txt = f"[{timestamp}] [{lvl}] [{comp}] {file_}:{func_}:{line_}{ev} - {msg}\n"

    with open(DEBUG_FILE_TXT, "a", encoding="utf-8") as tf:
        tf.write(line_txt)

def _do_log(level, component, msg, details=None):
    if details is None:
        details = {}
    nl = VERBOSITY_LEVELS.get(level.upper(), 10)
    if nl < CURRENT_VERBOSITY:
        return

    with log_lock:
        cf = inspect.currentframe().f_back
        entry = {
            "timestamp": datetime.now().isoformat(),
            "run_id": RUN_ID,
            "level": level.upper(),
            "component": component,
            "caller": {
                "file": os.path.basename(cf.f_code.co_filename),
                "function": cf.f_code.co_name,
                "line": cf.f_lineno
            },
            "message": msg,
            "details": details
        }
        _write_log_json(entry)
        _write_log_txt(entry)

def log_debug(msg: str, level="DEBUG", component="GENERAL", details=None):
    _do_log(level, component, msg, details)

def log_crypto_event(operation: str,
                     algorithm: str = None,
                     mode: str = None,
                     ephemeral_key: bytes = None,
                     argon_params: dict = None,
                     key_derived_bytes: bytes = None,
                     details: dict = None,
                     ephemeral: bool = False):
    if details is None:
        details = {}

    crypto_info = {
        "operation": operation,
        "algorithm": algorithm,
        "mode": mode,
        "ephemeral": ephemeral
    }
    if ephemeral_key is not None:
        import base64
        crypto_info["key_b64"] = base64.b64encode(ephemeral_key).decode()
    if key_derived_bytes is not None:
        import base64
        crypto_info["derived_key_b64"] = base64.b64encode(key_derived_bytes).decode()
    if argon_params:
        crypto_info["Argon2_Parameters"] = argon_params

    details["crypto_details"] = crypto_info
    _do_log("INFO", "CRYPTO", "Crypto operation", details)

def log_error(msg: str, exc: Exception = None, details=None):
    if details is None:
        details = {}
    if exc is not None:
        details["exception_type"] = type(exc).__name__
        details["exception_str"] = str(exc)
    _do_log("ERROR", "GENERAL", msg, details)

def start_timer() -> float:
    return time.perf_counter()

def end_timer(st: float) -> float:
    return (time.perf_counter() - st) * 1000.0

def append_recovery_guide():
    guide_lines = [
        "-------------------- MANUAL DECRYPTION GUIDE --------------------",
        "1. Identify chosen answers & gather shares.",
        "2. For CRITICAL shares, ephemeral Argon2id pass & salt are in logs => re-derive => decrypt.",
        "3. For non-critical, data is in plain (already in logs).",
        "4. Pass all recovered real shares into SSS.combine() => base64-decode final secret.",
        "-----------------------------------------------------------------"
    ]
    gjson = {"manual_decryption_guide": guide_lines}
    with log_lock:
        with open(DEBUG_FILE_JSON, "a", encoding="utf-8") as jf:
            jf.write(json.dumps(gjson, indent=2) + "\n")
        with open(DEBUG_FILE_TXT, "a", encoding="utf-8") as tf:
            for line in guide_lines:
                tf.write(line + "\n")

################################################################################
# END OF FILE: "debug_utils.py"
################################################################################




################################################################################
# START OF FILE: "input_utils.py"
################################################################################

"""
FILENAME:
"input_utils.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Handles user integer input & secret input with getpass.
Logs the integer input in plain to ensure everything needed is in logs.
"""

import getpass
from modules.debug_utils import log_debug
from modules.security_utils import sanitize_input, normalize_text

def get_valid_int(prompt, low, high):
    while True:
        print(prompt, end="", flush=True)
        val = input()
        try:
            num = int(val)
            if low <= num <= high:
                log_debug(f"User int input valid: {num}", level="INFO")
                return num
            else:
                print(f"Must be {low}..{high}")
        except:
            print("Invalid integer input.")

def get_nonempty_secret(prompt):
    while True:
        s = getpass.getpass(prompt)
        s = sanitize_input(normalize_text(s))
        if s.strip():
            if len(s) > 256:
                s = s[:256]
            return s
        print("Cannot be empty.")
        log_debug("Empty secret => re-prompt", level="WARNING")

################################################################################
# END OF FILE: "input_utils.py"
################################################################################




################################################################################
# START OF FILE: "log_processor.py"
################################################################################

"""
FILENAME:
"log_processor.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Tool to filter & display JSON logs from debug_logs.
"""

import argparse
import json
import sys
from pathlib import Path
from datetime import datetime

BASE_DIR = Path(__file__).parent.parent.resolve()
DEF_LOG_DIR = BASE_DIR / "logs" / "debug_logs"

def parse_args():
    ap = argparse.ArgumentParser("Forensic Log Processor")
    ap.add_argument("--log_dir", type=Path, default=DEF_LOG_DIR)
    ap.add_argument("--run_id", type=str)
    ap.add_argument("--component", type=str, help="e.g. CRYPTO, GENERAL, SYSTEM")
    ap.add_argument("--level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"])
    ap.add_argument("--start", type=str, help="Start time in ISO8601, e.g. 2025-03-08T17:00:00")
    ap.add_argument("--end", type=str, help="End time in ISO8601")
    ap.add_argument("--include_archive", action="store_true")
    ap.add_argument("--output", choices=["plain", "json"], default="plain")
    ap.add_argument("--crypto", action="store_true", help="Only show logs with component=CRYPTO")
    return ap.parse_args()

def load_log_file(fp: Path) -> list:
    entries = []
    try:
        with fp.open("r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    rec = json.loads(line)
                    entries.append(rec)
                except:
                    entries.append({"raw_line": line})
    except Exception as e:
        print(f"Failed reading {fp}: {e}", file=sys.stderr)
    return entries

def load_logs(log_dir: Path, include_archive: bool) -> list:
    main = list(log_dir.glob("debug_info*.json"))
    arch = []
    if include_archive:
        ardir = log_dir / "archive"
        if ardir.is_dir():
            arch = list(ardir.glob("debug_info*.json"))
    allf = main + arch
    out = []
    for ff in allf:
        out.extend(load_log_file(ff))
    return out

def filter_entries(entries: list,
                   run_id=None,
                   component=None,
                   level=None,
                   start=None,
                   end=None,
                   crypto_only=False):
    lvlmap = {"DEBUG": 10, "INFO": 20, "WARNING": 30, "ERROR": 40, "CRITICAL": 50}
    minlvl = lvlmap.get(level.upper(), 0) if level else 0
    start_dt = None
    if start:
        try:
            start_dt = datetime.fromisoformat(start)
        except:
            pass
    end_dt = None
    if end:
        try:
            end_dt = datetime.fromisoformat(end)
        except:
            pass

    ret = []
    for e in entries:
        if "timestamp" not in e:
            continue
        if run_id and e.get("run_id") != run_id:
            continue
        c = e.get("component", "")
        if crypto_only:
            if c != "CRYPTO":
                continue
        else:
            if component and c.lower() != component.lower():
                continue
        lv_str = e.get("level", "DEBUG").upper()
        lv_val = lvlmap.get(lv_str, 10)
        if lv_val < minlvl:
            continue
        try:
            dt = datetime.fromisoformat(e["timestamp"])
        except:
            continue
        if start_dt and dt < start_dt:
            continue
        if end_dt and dt > end_dt:
            continue
        ret.append(e)
    return ret

def print_plain(entries: list):
    for e in entries:
        ts = e.get("timestamp", "N/A")
        rid = e.get("run_id", "N/A")
        lvl = e.get("level", "N/A")
        comp = e.get("component", "N/A")
        c = e.get("caller", {})
        f = c.get("file", "?")
        fu = c.get("function", "?")
        ln = c.get("line", "?")
        msg = e.get("message", "")
        det = e.get("details", {})

        line = f"[{ts}] [{lvl}] [run_id={rid}] [{comp}] {f}:{fu}:{ln} - {msg}"
        print(line)

        if "crypto_details" in det:
            print("  CRYPTO DETAILS =>")
            crypto = det["crypto_details"]
            for k, v in crypto.items():
                print(f"    {k}: {v}")

        other_details = {k: v for k, v in det.items() if k != "crypto_details"}
        if other_details:
            import json
            print("  details=", json.dumps(other_details, indent=2))

        print()

def main():
    args = parse_args()
    if not args.log_dir.exists():
        print(f"Error: log_dir not exist: {args.log_dir}", file=sys.stderr)
        sys.exit(1)

    entries = load_logs(args.log_dir, args.include_archive)
    flt = filter_entries(
        entries,
        run_id=args.run_id,
        component=args.component,
        level=args.level,
        start=args.start,
        end=args.end,
        crypto_only=args.crypto
    )

    if args.output == "json":
        print(json.dumps(flt, indent=2))
    else:
        print_plain(flt)

if __name__ == "__main__":
    main()

################################################################################
# END OF FILE: "log_processor.py"
################################################################################




################################################################################
# START OF FILE: "security_utils.py"
################################################################################

"""
FILENAME:
"security_utils.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Basic text normalization, share hashing, etc.
"""

import unicodedata
import hashlib

def normalize_text(t: str) -> str:
    return unicodedata.normalize('NFKC', t)[:256]

def sanitize_input(t: str) -> str:
    return ''.join(ch for ch in t if ch not in "\0")

def validate_question(q) -> bool:
    if not isinstance(q, dict):
        return False
    if "text" not in q or "alternatives" not in q:
        return False
    if not isinstance(q["text"], str):
        return False
    if not isinstance(q["alternatives"], list):
        return False
    return True

def hash_share(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()

def verify_share_hash(data: bytes, expected: str) -> bool:
    return hashlib.sha256(data).hexdigest() == expected

################################################################################
# END OF FILE: "security_utils.py"
################################################################################




################################################################################
# START OF FILE: "split_utils.py"
################################################################################

"""
FILENAME:
"split_utils.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Splits the real secret into Shamir shares for correct answers,
and generates dummy shares for incorrect answers.
"""

import asyncio
import secrets
from modules.debug_utils import log_debug
from modules.SSS import sss_split

async def split_secret_and_dummy(real: bytes,
                                 correct_count: int,
                                 incorrect_count: int,
                                 real_thr: int,
                                 pad: int = 128):
    """
    Splits the real secret into 'correct_count' shares requiring 'real_thr' to reconstruct.
    Also generates 'incorrect_count' dummy shares (random data) with the same length
    so that incorrect picks do not help reconstruct the real secret.
    """
    log_debug(f"Splitting real secret: correct_count={correct_count}, threshold={real_thr}", level="INFO")

    # Create the real shares
    real_shares = await sss_split(real, correct_count, real_thr, pad=pad)
    share_len = len(real_shares[0]) if real_shares else 0

    # Create dummy shares for incorrect picks
    dummy_shares = []
    for _ in range(incorrect_count):
        dummy_chunk = bytearray(secrets.randbits(8) for _ in range(share_len))
        dummy_shares.append(dummy_chunk)

    return real_shares, dummy_shares

################################################################################
# END OF FILE: "split_utils.py"
################################################################################




################################################################################
# START OF FILE: "SSS.py"
################################################################################

"""
FILENAME:
"SSS.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
SSS: Provides sss_split() & sss_combine() for Shamir's Secret Sharing in GF(2^8).
"""

def gf_add(a: int, b: int) -> int:
    return a ^ b

LOG_TABLE = bytes([
    0x00,0xff,0xc8,0x08,0x91,0x10,0xd0,0x36,0x5a,0x3e,0xd8,0x43,0x99,0x77,0xfe,0x18,
    0x23,0x20,0x07,0x70,0xa1,0x6c,0x0c,0x7f,0x62,0x8b,0x40,0x46,0xc7,0x4b,0xe0,0x0e,
    0xeb,0x16,0xe8,0xad,0xcf,0xcd,0x39,0x53,0x6a,0x27,0x35,0x93,0xd4,0x4e,0x48,0xc3,
    0x2b,0x79,0x54,0x28,0x09,0x78,0x0f,0x21,0x90,0x87,0x14,0x2a,0xa9,0x9c,0xd6,0x74,
    0xb4,0x7c,0xde,0xed,0xb1,0x86,0x76,0xa4,0x98,0xe2,0x96,0x8f,0x02,0x32,0x1c,0xc1,
    0x33,0xee,0xef,0x81,0xfd,0x30,0x5c,0x13,0x9d,0x29,0x17,0xc4,0x11,0x44,0x8c,0x80,
    0xf3,0x73,0x42,0x1e,0x1d,0xb5,0xf0,0x12,0xd1,0x5b,0x41,0xa2,0xd7,0x2c,0xe9,0xd5,
    0x59,0xcb,0x50,0xa8,0xdc,0xfc,0xf2,0x56,0x72,0xa6,0x65,0x2f,0x9f,0x9b,0x3d,0xba,
    0x7d,0xc2,0x45,0x82,0xa7,0x57,0xb6,0xa3,0x7a,0x75,0x4f,0xae,0x3f,0x37,0x6d,0x47,
    0x61,0xbe,0xab,0xd3,0x5f,0xb0,0x58,0xaf,0xca,0x5e,0xfa,0x85,0xe4,0x4d,0x8a,0x05,
    0xfb,0x60,0xb7,0x7b,0xb8,0x26,0x4a,0x67,0xc6,0x1a,0xf8,0x69,0x25,0xb3,0xdb,0xbd,
    0x66,0xdd,0xf1,0xd2,0xdf,0x03,0x8d,0x34,0xd9,0x92,0x0d,0x63,0x55,0xaa,0x49,0xec,
    0xbc,0x95,0x3c,0x84,0x0b,0xf5,0xe6,0xe7,0xe5,0xac,0x7e,0x6e,0xb9,0xf9,0xda,0x8e,
    0x9a,0xc9,0x24,0xe1,0x0a,0x15,0x6b,0x3a,0xa0,0x51,0xf4,0xea,0xb2,0x97,0x9e,0x5d,
    0x22,0x88,0x94,0xce,0x19,0x01,0x71,0x4c,0xa5,0xe3,0xc5,0x31,0xbb,0xcc,0x1f,0x2d,
    0x3b,0x52,0x6f,0xf6,0x2e,0x89,0xf7,0xc0,0x68,0x1b,0x64,0x04,0x06,0xbf,0x83,0x38,
])
EXP_TABLE = bytes([
    0x01,0xe5,0x4c,0xb5,0xfb,0x9f,0xfc,0x12,0x03,0x34,0xd4,0xc4,0x16,0xba,0x1f,0x36,
    0x05,0x5c,0x67,0x57,0x3a,0xd5,0x21,0x5a,0x0f,0xe4,0xa9,0xf9,0x4e,0x64,0x63,0xee,
    0x11,0x37,0xe0,0x10,0xd2,0xac,0xa5,0x29,0x33,0x59,0x3b,0x30,0x6d,0xef,0xf4,0x7b,
    0x55,0xeb,0x4d,0x50,0xb7,0x2a,0x07,0x8d,0xff,0x26,0xd7,0xf0,0xc2,0x7e,0x09,0x8c,
    0x1a,0x6a,0x62,0x0b,0x5d,0x82,0x1b,0x8f,0x2e,0xbe,0xa6,0x1d,0xe7,0x9d,0x2d,0x8a,
    0x72,0xd9,0xf1,0x27,0x32,0xbc,0x77,0x85,0x96,0x70,0x08,0x69,0x56,0xdf,0x99,0x94,
    0xa1,0x90,0x18,0xbb,0xfa,0x7a,0xb0,0xa7,0xf8,0xab,0x28,0xd6,0x15,0x8e,0xcb,0xf2,
    0x13,0xe6,0x78,0x61,0x3f,0x89,0x46,0x0d,0x35,0x31,0x88,0xa3,0x41,0x80,0xca,0x17,
    0x5f,0x53,0x83,0xfe,0xc3,0x9b,0x45,0x39,0xe1,0xf5,0x9e,0x19,0x5e,0xb6,0xcf,0x4b,
    0x38,0x04,0xb9,0x2b,0xe2,0xc1,0x4a,0xdd,0x48,0x0c,0xd0,0x7d,0x3d,0x58,0xde,0x7c,
    0xd8,0x14,0x6b,0x87,0x47,0xe8,0x79,0x84,0x73,0x3c,0xbd,0x92,0xc9,0x23,0x8b,0x97,
    0x95,0x44,0xdc,0xad,0x40,0x65,0x86,0xa2,0xa4,0xcc,0x7f,0xec,0xc0,0xaf,0x91,0xfd,
    0xf7,0x4f,0x81,0x2f,0x5b,0xea,0xa8,0x1c,0x02,0xd1,0x98,0x71,0xed,0x25,0xe3,0x24,
    0x06,0x68,0xb3,0x93,0x2c,0x6f,0x3e,0x6c,0x0a,0xb8,0xce,0xae,0x74,0xb1,0x42,0xb4,
    0x1e,0xd3,0x49,0xe9,0x9c,0xc8,0xc6,0xc7,0x22,0x6e,0xdb,0x20,0xbf,0x43,0x51,0x52,
    0x66,0xb2,0x76,0x60,0xda,0xc5,0xf3,0xf6,0xaa,0xcd,0x9a,0xa0,0x75,0x54,0x0e,0x01,
])

def gf_add(a: int, b: int) -> int:
    return a ^ b

def gf_mult(a: int, b: int) -> int:
    if a == 0 or b == 0:
        return 0
    la = LOG_TABLE[a]
    lb = LOG_TABLE[b]
    x = (la + lb) % 255
    return EXP_TABLE[x]

def gf_div(a: int, b: int) -> int:
    if b == 0:
        raise ZeroDivisionError("GF division by zero")
    if a == 0:
        return 0
    la = LOG_TABLE[a]
    lb = LOG_TABLE[b]
    diff = (la - lb + 255) % 255
    return EXP_TABLE[diff]

def gf_eval(coeffs: bytes, x: int, deg: int) -> int:
    val = coeffs[deg]
    for i in reversed(range(deg)):
        val = gf_mult(val, x) ^ coeffs[i]
    return val

def gf_interp(xs: bytes, ys: bytes, x: int) -> int:
    if len(xs) != len(ys):
        raise ValueError("sample mismatch for gf_interp")
    val = 0
    n = len(xs)
    for i in range(n):
        basis = 1
        for j in range(n):
            if i == j:
                continue
            num = x ^ xs[j]
            den = xs[i] ^ xs[j]
            tmp = gf_div(num, den)
            basis = gf_mult(basis, tmp)
        val ^= gf_mult(ys[i], basis)
    return val

def pack_len(n: int) -> bytes:
    return n.to_bytes(2, 'big')

def unpack_len(b: bytes) -> int:
    return int.from_bytes(b, 'big')

async def sss_split(secret: bytes, shares: int, threshold: int, pad: int=128) -> list[bytearray]:
    if shares < threshold:
        raise ValueError("shares < threshold in sss_split")
    if pad < len(secret):
        raise ValueError("pad must >= secret length")

    import secrets
    length_part = pack_len(len(secret))
    extra = pad - 2 - len(secret)
    if extra < 0:
        raise ValueError("pad too small unexpectedly")
    padded = length_part + secret + b'\x00' * extra

    out = []
    for _ in range(shares):
        out.append(bytearray(pad + 1))

    deg = threshold - 1
    coords = list(range(1, shares + 1))
    for i in range(shares):
        out[i][pad] = coords[i]

    for byte_index in range(pad):
        poly = bytearray(deg + 1)
        poly[0] = padded[byte_index]
        for d in range(1, deg + 1):
            poly[d] = secrets.randbits(8)

        for i in range(shares):
            x = coords[i]
            val = gf_eval(poly, x, deg)
            out[i][byte_index] = val

    return out

async def sss_combine(shares: list[bytes]) -> bytes:
    if not shares:
        raise ValueError("No shares passed to sss_combine")
    length = len(shares[0])
    pad = length - 1
    xcoords = []
    for s in shares:
        if len(s) != length:
            raise ValueError("Inconsistent share length")
        xcoords.append(s[pad])
    if len(set(xcoords)) != len(shares):
        raise ValueError("Duplicate x-coord in shares")

    n = len(shares)
    rec = bytearray(pad)
    for b_i in range(pad):
        xs = bytearray(n)
        ys = bytearray(n)
        for i in range(n):
            xs[i] = xcoords[i]
            ys[i] = shares[i][b_i]
        val = gf_interp(xs, ys, 0)
        rec[b_i] = val

    real_len = unpack_len(rec[:2])
    if real_len > pad - 2:
        return bytes(rec)
    return rec[2:2 + real_len]

################################################################################
# END OF FILE: "SSS.py"
################################################################################




################################################################################
# START OF FILE: "ui_utils.py"
################################################################################

"""
FILENAME:
"ui_utils.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Implements arrow-based selection of answers & toggling question type.
"""

import curses
from modules.debug_utils import log_debug
from modules.security_utils import sanitize_input, normalize_text

def arrow_select_clear_on_toggle(stdscr, q_num, q_text, alts,
                                 pre_selected=None, pre_qtype=0, fixed_type=None):
    """
    Allows user to move with UP/DOWN, toggle selections with SPACE,
    optionally toggle question type (CRITICAL vs STANDARD) with 'T', unless fixed_type is set.
    If no selection is made, user is prompted again before confirming.
    """
    curses.curs_set(0)
    q_text = sanitize_input(normalize_text(q_text))
    alts = [sanitize_input(normalize_text(a)) for a in alts]
    idx = 0
    chosen_mask = [False] * len(alts)
    toggle_allowed = (fixed_type is None)
    qtype = 1 if (fixed_type and fixed_type.upper() == "CRITICAL") else pre_qtype

    if pre_selected:
        for i, a in enumerate(alts):
            if a in pre_selected:
                chosen_mask[i] = True

    while True:
        stdscr.clear()
        stdscr.addstr(f"Q{q_num}. {q_text}\n\n")
        for i, alt in enumerate(alts):
            mark = "[X]" if chosen_mask[i] else "[ ]"
            arrow = "->" if i == idx else "  "
            stdscr.addstr(f"{arrow} {mark} {chr(65+i)}. {alt}\n")
        mode_str = "CRITICAL" if qtype == 1 else "STANDARD"
        if not toggle_allowed:
            mode_str += " (fixed)"
        stdscr.addstr(f"\nCurrent Type: {mode_str}\n")
        help_ = "UP/DOWN=move, SPACE=toggle"
        if toggle_allowed:
            help_ += ", T=switch type"
        help_ += ", ENTER=confirm.\n"
        stdscr.addstr(help_)

        key = stdscr.getch()
        if key == curses.KEY_UP and idx > 0:
            idx -= 1
        elif key == curses.KEY_DOWN and idx < len(alts) - 1:
            idx += 1
        elif key == ord(' '):
            chosen_mask[idx] = not chosen_mask[idx]
        elif toggle_allowed and key in [ord('t'), ord('T')]:
            # Switching type resets all selections
            chosen_mask = [False] * len(alts)
            qtype = 1 - qtype
        elif key == ord('\n'):
            if not any(chosen_mask):
                stdscr.addstr("\nError: Must select at least one.\n")
                stdscr.refresh()
                curses.napms(1500)
            else:
                break

    selected = [alts[i] for i, v in enumerate(chosen_mask) if v]
    mode_str = "CRITICAL" if qtype == 1 else "STANDARD"
    log_debug(f"Q{q_num} picks. Type={mode_str}", level="INFO")
    return selected, qtype

def arrow_select_no_toggle(stdscr, q_num, q_text, alts,
                           pre_selected=None):
    """
    Same arrow-based selection as above, but no question-type toggle.
    For the final answering phase.
    """
    curses.curs_set(0)
    q_text = sanitize_input(normalize_text(q_text))
    alts = [sanitize_input(normalize_text(a)) for a in alts]
    idx = 0
    chosen_mask = [False] * len(alts)
    if pre_selected:
        for i, a in enumerate(alts):
            if a in pre_selected:
                chosen_mask[i] = True

    while True:
        stdscr.clear()
        stdscr.addstr(f"Q{q_num}. {q_text}\n\n")
        for i, alt in enumerate(alts):
            mark = "[X]" if chosen_mask[i] else "[ ]"
            arrow = "->" if i == idx else "  "
            stdscr.addstr(f"{arrow} {mark} {chr(65+i)}. {alt}\n")
        stdscr.addstr("\nUP/DOWN=move, SPACE=toggle, ENTER=confirm.\n")

        key = stdscr.getch()
        if key == curses.KEY_UP and idx > 0:
            idx -= 1
        elif key == curses.KEY_DOWN and idx < len(alts) - 1:
            idx += 1
        elif key == ord(' '):
            chosen_mask[idx] = not chosen_mask[idx]
        elif key == ord('\n'):
            if not any(chosen_mask):
                stdscr.addstr("\nError: Must select at least one.\n")
                stdscr.refresh()
                curses.napms(1500)
            else:
                break

    selected = [alts[i] for i, v in enumerate(chosen_mask) if v]
    log_debug(f"Q{q_num} final picks", level="INFO")
    return selected

def editing_menu(chosen):
    """
    Command-based menu for re-entering or single-editing questions.
    """
    print("\n--- Editing Menu ---")
    print("Press 'E' to re-enter ALL answers.")
    print(f"Or type question #(1..{len(chosen)}) to edit a single. 'N' if done.\n")
    cmd = input("Choice: ").strip().upper()
    if cmd == 'N':
        return True
    if cmd == 'E':
        import curses
        for i, qdict in enumerate(chosen, 1):
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, i, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            if qdict.get("force_type"):
                qdict["is_critical"] = (qdict["force_type"].upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)
        return False
    try:
        num = int(cmd)
        if 1 <= num <= len(chosen):
            import curses
            qdict = chosen[num - 1]
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, num, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            if qdict.get("force_type"):
                qdict["is_critical"] = (qdict["force_type"].upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)
        else:
            print("Invalid question #.")
    except:
        print("Unrecognized cmd.")
    return False

def final_edit_menu(chosen):
    """
    Command-based menu for final pre-generation edits or abort.
    """
    print("\n--- Final Editing Menu ---")
    print("Press 'G' => generate secret. 'E' => re-enter ALL. or # => single. 'N'=>exit\n")
    cmd = input("Your choice: ").strip().upper()
    if cmd in ['G', 'N']:
        return cmd
    if cmd == 'E':
        import curses
        for i, qdict in enumerate(chosen, 1):
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, i, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            if qdict.get("force_type"):
                qdict["is_critical"] = (qdict["force_type"].upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)
        return None
    try:
        num = int(cmd)
        if 1 <= num <= len(chosen):
            import curses
            qdict = chosen[num - 1]
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, num, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            if qdict.get("force_type"):
                qdict["is_critical"] = (qdict["force_type"].upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)
        else:
            print("Invalid question #.")
    except:
        print("Unrecognized cmd.")
    return None

################################################################################
# END OF FILE: "ui_utils.py"
################################################################################




################################################################################
# START OF FILE: "__init__.py"
################################################################################

"""
FILENAME:
"__init__.py"

PERMANENT FILE DESCRIPTION – DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

__all__ = [
    "debug_utils",
    "input_utils",
    "log_processor",
    "security_utils",
    "split_utils",
    "SSS",
    "ui_utils"
]

################################################################################
# END OF FILE: "__init__.py"
################################################################################




"""
MANDATORY FILE LIST:
CipherForge.py
SSS.py
__init__.py
debug_utils.py
input_utils.py
log_processor.py
main.py
security_utils.py
split_utils.py
ui_utils.py

Before making any code updates, you are strictly required to confirm that all required files are present in the updated implementation. This verification is mandatory and must not be skipped under any circumstances.
"""
